## Strings

### a 

Käynnistin virtuaalikoneen ja latasin ezbin-challenges.zip. Purin sen ja navigoin passtr kansioon ja suoritin sen komennolla: ./passtr . Tämän jälkeen syötin väärän salasanan jonka jälkeen ajoin
komennon strings -n 5 passtr joka tulostaa >=5 mittaiset merkkijonot. Tämän jälkeen löydin sala-hakkeri-321 salasanan ja flagin. Lisäksi tutkiskelin https://low-orbit.net/linux-command-strings ja https://www.youtube.com/watch?v=6uX_25PQV5A
avulla stringsin komentoja. Tehtävän kesto: 10min

<img width="727" height="324" alt="image" src="https://github.com/user-attachments/assets/e81a9b74-eb08-4fa2-9272-4b1caaa92ce3" />


<img width="831" height="97" alt="image" src="https://github.com/user-attachments/assets/8a0d12b1-844a-4c61-92ea-c3360d9a9069" />

### b

Tämä tehtävä olikin vähän kinkkisempi kun jouduin tutustumaan hex aakkosiin ja c -ohjelmointikieleen sekä kuinka XOR salaus toimii. Googletin suoraan "Xor obfuscation password example c" ja tuli 
https://medium.com/@lsecqt/encrypting-shellcode-with-xor-offensive-coding-in-c-5a42cb978d6e vastaan. Aloin tutustumaan sen ja tulkkasin tekoälyn avulla jokaisen koodirivin merkitystä ja xor salauksen toimintaa.
Tämä oli välttämätöntä että ymmärtäisin c -ohjelmointikieltä tehtävän suorittamiseen. Kääntelin artikkelin mukaisesti löytämääni sala-hakkeri-321 salasanaa hex -muotoon ja takaisin http://www.csc.villanova.edu/~tway/resources/ascii-table.html
avulla jotta ymmärtäisin merkkejä jotenkin. Tämän jälkeen yhdistelin esimerkkitehtävää alkuperäisen passtr.c lähdekoodin kanssa. Aikani kikkailtua ja selviteltyä mikä tekee mitäkin, sain toimivan koodin joka tarkasti salasanan.

```c

// passtr - a simple static analysis warm up exercise
// Copyright 2024 Tero Karvinen https://TeroKarvinen.com

#include <stdio.h>
#include <string.h>

int main() {

	char password[20] = "\x38\x2a\x27\x2a\x66\x23\x2a\x20\x20\x2e\x39\x22\x66\x78\x79\x7a";
	char encodekey = 0x4b;
	int pw_len = 16;
	char decoded_password[20];

	for(int i = 0; i < 16; i++) {
        decoded_password[i] = password[i] ^ encodekey;
    }
	
	printf("What's the password?\n");
	scanf("%19s", password);
	if (0 == strcmp(password, decoded_password)) {
		printf("Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}\n");
	} else {
		printf("Sorry, no bonus.\n");
	}
	return 0;

}

```

Tämän jälkeen ajoin vielä strings -n 6 a.out komennon ja tarkastin ettei salasanaa näy, toimi. Tehtävän kesto 3h

<img width="719" height="76" alt="image" src="https://github.com/user-attachments/assets/dffed5fd-abb7-4ec4-9ca5-8e629bf984de" />

### c

Tehtävänannon mukaan tämän tehtävän pitäisi tuottaa enemmän haasteita. Aloin ratkomaan tilannetta navigoimalla tehtävänannon kansioon ja syötin strings packd joka antoi komentokehotteeseen taas listan merkkijonoja.

<img width="651" height="496" alt="image" src="https://github.com/user-attachments/assets/00bf6db2-ca10-4a83-bde9-ffb625a74075" />

Kuten kuvasta voi huomata, lähellä salasanan tarkastusta on ilmeisesti salasana osittain näkyvissä: "piilos-An", jos oikein tulkitsin. Äskeisen tehtävän osalta hex merkit tulivat suhteellisen tutuiksi, joten 
syötin suoraan hexdump -C https://www.geeksforgeeks.org/linux-unix/hexdump-command-in-linux-with-examples/ ohjeiden mukaisesti. Tämä antoi seuraavanlaisen setin komentokehotteeseen:

<img width="773" height="150" alt="image" src="https://github.com/user-attachments/assets/02e07d02-6de5-422e-8b8a-c99d7d657cca" />

Navigoin manuaalisesti hiirtä hyödyntäen kohtaan jossa on viitteitä stringsin tuomasta osittaisesta salasanasta ja kohdan jossa on salasana osittain. Vasemmalla näkee jokaisen hex desimaalin ja oikealla sitä vastaavan merkin kaiketi.
Käytännössä nyt kun tiesin salasanan osittain, pystyn poimimaan ensimmäisen suoran veikkaukseni missä salasana sijaitsee ja valitsemalla hex desimaalit sen mukaan: 

> 00 70 69 69 6c 6f 73 2d 41 6e 01 0d

Selailin ylhäällä mainitsemani lähteen mukaista taulukkoa ja heräsi pieniä kysymysmerkkejä kun 0 alkuiset heksadesimaalit ei ilmeisesti ole kirjaimia joten aloin epäilemään onko ratkaisu sittenkään vielä käsillä.
Syötin heksadesimaalit verkosta löytyvään https://www.duplichecker.com/hex-to-text.php työkaluun joka käänti tekstiksi:

<img width="526" height="49" alt="image" src="https://github.com/user-attachments/assets/e09b308b-48f1-4657-be32-5aec69f476db" />

eli täyttä turskaa. Jatkoin hexdumpin tutkimista kun ei muutakaan ideaa ollut ja törmäsin upx tekstiin jolla tiedosto oli paketoitu.

<img width="778" height="435" alt="image" src="https://github.com/user-attachments/assets/3d3b9a1d-36a9-417d-9037-0c5b97cca336" />

Asensin sudo apt install upx komennolla työkalun jolla paketoidaan ja puretaan tiedostoja. Kun upx oli latautunut, ajoin upx -h jotta sain komennot näkyviin. Tämän jälkeen purin paketin ajamalla upx -d packd -komennon. Sen jälkeen ajoin strings packd -komennon ja 
selasin uudelleen salasana -kohtaan, joka oli nyt jo pidentynyt mystisesti! 

<img width="696" height="92" alt="image" src="https://github.com/user-attachments/assets/5782d1cf-ead8-4a61-aa97-528b7301873b" />

Syötin salasanan ohjelmaan ja tämä oli oikea salasana. Tehtävän kesto: 1h

<img width="739" height="76" alt="image" src="https://github.com/user-attachments/assets/0fead6b8-84f6-4017-9ce9-c4f0968ba54b" />



## Lähteet

https://www.programiz.com/c-programming/library-function/string.h/strcmp

https://medium.com/@lsecqt/encrypting-shellcode-with-xor-offensive-coding-in-c-5a42cb978d6e

http://www.csc.villanova.edu/~tway/resources/ascii-table.html

https://low-orbit.net/linux-command-strings

https://www.youtube.com/watch?v=6uX_25PQV5A

https://www.geeksforgeeks.org/linux-unix/hexdump-command-in-linux-with-examples/

https://www.duplichecker.com/hex-to-text.php

https://github.com/upx/upx
